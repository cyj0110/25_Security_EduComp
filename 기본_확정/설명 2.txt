# 악성코드

## 바이너리 분석

### 개요

원격훈련체계에서 윈도우 바이너리 분석 ... 내용 읽고 다운로드 유도
1) 가상 자산(윈도우) 오픈
2) 링크 복사 안됨, 직접 보고 입력해서 파일 다운로드 후 저장
3) cmd로 파일 열어보기
4) Hello! Welcome EASY Reversing! -> 무언가 입력했는데 fail 뜨면서 프로그램 종료. 힌트에 리버싱 crackme라고 되어있는 걸 보아, 분석 도구를 이용해 리버싱을 진행

---

### 힌트(풀이시간) - 20분

내용

---

### 문제 풀이

1. 마찬가지로, x32dbg 프로그램을 열면, F9를 눌러 EntryPoint로 진입합니다.
2. 다음을 찾기 -> 현재 모듈 -> 문자열 참조 에서 저번 문제와 비슷하게 %s 서식 지정자와 Good, Fail이 있는 것으로 보아 어떤 특정한 문자열을 입력받아, 성공과 실패로 분기가 될 것이라는 것을 추정할 수 있습니다.
3. 서식 지정자가 있는 주소에 우클릭 -> 중단점(breakpoint) 설정을 누르고 다시 CPU로 돌아옵니다.
4. F9를 눌러 설정한 breakpoint까지 진행을 해보도록 하겠습니다.
5. 다음 명령어로 진행을 하면 더 이상 진행이 되지 않는 것을 알 수가 있는데, 실행 명령어 창에 입력을 해보면 다음 명령어로 넘어가지는 것을 확인할 수 있습니다.
6. 주석을 살펴보면 63: 'c', 61: 'a', 64: 'd' 이렇게 16진수와 그에 해당하는 문자가 뭔지 나타내고 있는 것을 확인할 수 있습니다.
7. 진행을 하다보면 jne 101-03.401249 명령어에서 빨간색 화살표로 점프가 될것이라는 것을 알 수 있는데, jne는 jump if not equal, 즉 같지 않으면 점프라는 뜻이 됩니다.
아까 Zero Flag 값이 0이면 같지 않음, 즉 점프를 하게 되므로, 의도적으로 1로 만들어줘서 프로그램을 의도적으로 조작해볼 수 있습니다.
8. 그러면 점프가 되지 않고, 다음 명령어 줄로 이동하는 것을 알 수가 있습니다.
9. 그런데 여기서 알아야 할 것은 앞으로 나오게 되는 명령어 구조가 이렇게 된다는 것입니다.
```
mov edx, 1
imul eax, edx, 0
movsx ecx, byte ptr ss:[ebp+eax-28]
cmp ecx, 63
jne 101-03.401249
```

이런식의 구조에서 변형되어서 나타내게 됩니다.
우리가 아는 대부분의 CPU의 어셈블리 명령어의 구조는

[Op Code(명령어) opr1 opr2] 의 형태로 이루어져있습니다.
opr1과 opr2를 명령어로 계산해서 opr1에 저장하는 구조입니다.

하나씩 보자면
mov edx, 1은 edx라는 레지스터에 1을 복사해서 저장하라는 뜻입니다.
imul eax, edx, 0은 eax라는 레지스터에 edx와 0을 곱해서 저장하겠다는 뜻입니다.
movsx ecx, byte ptr ss:[ebp+eax-28] 은 ss라는 스택에서 ebp+eax-28의 값을 가져와 ecx에 저장한다는 뜻입니다.
EBP, ESP는 스택에서 쓰이는 레지스터인데, ebp 에서 28을 뺀 값이 esp 라는 것을 확인할 수 있다. (덤프에서 따라가기 해서 cmd 창에 내가 입력한 내용 보여주기) 그래서 레지스터 값을 더하면 이 스택 배열에서 인덱스 값으로 쓰인다는 것을 확인할 수 있음.
cmp ecx, 63 ecx와 0x63을 비교해서 그 다음 ZF를 설정하는데, 같으면 1, 같지 않으면 0으로 설정됩니다. 그래서 보통 다음에 jump 문이 나옵니다.
jne 101-03.401249 즉 아까 설명했듯이 같지 않으면 점프이므로, ZF가 0이면 점프, 1이면 점프하지 않게 됩니다.

(입력: 12345678901234567)

### 0번째 인덱스
이런식의 명령어 구조를 기억한 채로, 실행시키면서 보도록 하겠습니다.
(첫번째 'c' 보여주면서 ZF 통과)
(메모장 켜서 스택의 0번째 인덱스가 'c' 임을 표시.)

### 1번째 인덱스
다음 구조는 mov edx, 1 -> edx 레지스터에 1을 저장하고
shl edx, 0 비트연산을 진행하는 명령어 인데, shift left 즉 왼쪽으로 비트를 이동시키는 연산입니다. 그런데 지금은 0으로 되어있으니 움직이지 않습니다. edx는 여전히 1입니다.
movsx 스택은 1번째 인덱스라는 것을 표시 eax에는 '(사용자가 입력한 1번째 내용)'이 저장
cmp eax, 61 -> '2'와 'a'는 다르므로 점프가 됨.
jne 에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 1번째 인덱스가 'a' 임을 표시.)

### 2번째 인덱스
그 다음은 mov ecx, 1 -> ecx 레지스터에 1을 저장하고
shl ecx, 1 -> ecx 레지스터에 저장된 값인 1을 왼쪽으로 1칸 옮기는 연산입니다.
0001(2) -> 0010(2) = 2(10) ecx에는 '(사용자가 입력한 2번째 내용)'이 저장됩니다.
movsx 스택에서 2번째 인덱스에는 '3'이 저장되어 있고, edx에 '3'이 저장됨.
cmp edx, 64 -> '3'과 'd'는 다르므로 점프가 됨.
jne 에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 2번째 인덱스가 'd'임을 표시.)

### 3번째 인덱스
mov eax, 1 -> eax 레지스터에 1을 복사해서 저장하고,
imul ecx, eax, 3 -> eax와 3을 곱한 값을 ecx에 저장하고 (ecx는 3)
movsx 스택에서 3번째 인덱스에는 '4'가 저장되어 있고, edx에 '4'가 저장됨.
cmp edx, 74 -> '4'는 't'와 다르므로 점프가 됨.
jne 에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 3번째 인덱스가 't'임을 표시.)

### 4번째 인덱스
mov eax, 1 -> eax 레지스터에 1을 복사해서 저장
shl eax, 2 -> eax에 저장된 값을 왼쪽으로 2칸 쉬프트 연산 0001(2) -> 0100(2) = 4(10)
movsx 스택에서 4번째 인덱스를 가져옴 : '5' 를 ecx에 저장
cmp ecx, 7B -> '5'와 '{'는 다르므로 점프가 됨.
jne에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 4번째 인덱스가 '{'임을 표시.)

### 14번째 인덱스
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, E -> edx(1) * E(16진수 E는 10진수로 14) -> eax에 '14' 저장
movsx 스택에서 14번째 인덱스를 가져와서 ecx에 저장
sub ecx, 3 -> ecx에 저장된 값에서 3을 뺌
cmp ecx, 30 -> ecx와 30을 비교하는데, 윗 줄에서 3을 빼줬기 때문에 원래 스택에 들어있어야 할 값은 3을 더해서 33이 됩니다.(0x33)
(아스키코드 표 사진 보여주고 메모장 켜서 스택의 14번째 인덱스가 '3' 임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 13번째 인덱스
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, D -> edx * D = 1 * D(16진수 D는 10진수로 13) -> eax에 '13'가 저장
movsx 스택에서 'D'번째 즉, 13번째 인덱스를 가져와서 ecx에 저장
add ecx, 1 -> ecx에 저장된 값에서 1을 더함
cmp ecx, 73 -> ecx와 73을 비교, 윗 줄에서 1을 더해줬기 때문에 원래 스택에 들어있어야 할 값은 1을 빼서 72가 됩니다.(0x72)
(아스키코드 표 사진 보여주고 메모장 켜서 스택의 13번째 인덱스가 'r'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 15번째 인덱스(테스트)
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, F -> edx와 F를 곱해서 eax에 저장. -> eax = 'F' (16진수 F는 10진수로 15)
movsx 스택에서 'F'번째 값 즉, 15번째 인덱스를 가져와서 ecx에 저장
test ecx, ecx -> test는 자기 자신과 AND 연산을 하는 명령어라 ecx 값 그대로가 저장됩니다. 즉 '사용자가 입력한 15번째 인덱스'가 그대로 저장
이 때 ZF는 ecx가 '0'일 때만 1로 표시되고, 그 외에는 전부 '0'으로 변경됩니다.
그리고 다음 je 명령어가 나왔는데, je는 jump if equal, 즉 같아야 점프이지만 지금은 같지가 않습니다. ZF도 같을 때 '1'인데, 지금은 앞에서 '0'으로 저장되어 있기 때문에 그대로 다음으로 넘어가면 됩니다.

### 5번째 인덱스
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, 5 -> edx와 5를 곱해서 eax에 저장. -> '5'
movsx 스택에서 5번째 인덱스를 가져와서 ecx에 저장
cmp ecx, 77 -> ecx에 저장된 값을 0x77과 비교 'w'
(메모장 켜서 스택의 5번째 인덱스가 'w'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 10번째 인덱스
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, A -> edx와 'A'를 곱해서 eax에 저장. -> eax = 'A' (16진수 A는 10진수로 10)
movsx 스택에서 10번째 인덱스에 있는 값을 가져와 ecx에 저장. -> ecx = '1'
mov edx, 1 -> edx 레지스터에 1을 복사해서 저장
imul eax, edx, E -> edx와 'E'를 곱해서 eax에 저장. -> eax = 'E' (16진수 E는 10진수로 14)
movsx 스택에서 14번째 인덱스에 있는 값을 가져와 edx에 저장. -> edx = '5' 
add ecx, edx -> ecx와 edx를 더해서 ecx에 저장하라는 뜻
cmp ecx, A0 -> ecx와 0xA0를 비교

사용자가 입력한 문자열 스택 A가 있다고 하고
(메모장과 계산기 켜서)
A[10] + A[14] = 0xA0
14번째에 있던 값은 알고 있으므로
A[10] + 0x33('3') = 0xA0
A[10] = 0xA0 - 0x33 = 0x6D ('m')

즉, 10번째 인덱스에 있던 원래의 값은 'm'이 되어야 jump하지 않고 통과합니다.
(메모장 켜서 스택의 10번째 인덱스가 'm'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 9번째 인덱스
mov eax, 1 -> eax 레지스터에 1을 복사해서 저장
imul ecx, eax, 9 -> eax와 '9'를 곱해서 ecx에 저장 -> ecx = '9'
movsx 스택에서 9번째 인덱스에 있는 값을 가져와 edx에 저장. -> edx = '0'
mov eax, 1 -> eax 레지스터에 1을 복사해서 저장
imul ecx, eax, A -> eax와 'A'를 곱해서 ecx에 저장 -> ecx = 'A' (16진수 'A'는 10진수로 '10')
movsx 스택에서 10번째 인덱스에 있는 값을 가져와 eax에 저장. -> eax = '1'
sub edx, eax -> edx에서 eax를 뺀 값을 edx에 저장
cmp edx, FFFFFFC3

A[9] - 0x6D = FFFFFFC3
0x6D - A[9] = -FFFFFFC3

음수를 취하기 위해 2진수로 바꿔서 2의 보수로 계산합니다.
(메모장과 계산기 켜서)
FFFFFFC3

1111 1111 1111 1111 1111 1111 1100 0011 (2)
-> 비트 반전
0000 0000 0000 0000 0000 0000 0011 1100 (2)
-> +1
=============================
0000 0000 0000 0000 0000 0000 0011 1101 (2)

0011 = 3
1101 = 13(D)

0x3D

0x6D - A[9] = 0x3D
A[9] = 0x6D - 0x3D = 0x30 ('0')

(메모장 켜서 스택의 9번째 인덱스가 '0'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 15번째 인덱스
mov ecx, 1 -> ecx에 1을 복사해서 저장.
imul edx, ecx, F -> ecx와 'F'를 곱해서 edx에 저장 -> edx = 'F' (16진수 F는 10진수로 15)
movsx 스택에서 15번째 인덱스에 있는 값을 가져와 eax에 저장. -> eax = '6'
cmp eax, 76 -> eax와 76을 비교
A[15]에 원래 들어있던 값은 0x76. 즉 'v'
(메모장 켜서 스택의 15번째 인덱스가 'v'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 16번째 인덱스
그 다음은 mov ebp - 4 위치에 0x7D를 저장하고
jump를 해서 다음 mov 명령어는 무시가 되고 넘어갑니다.
그리고 mov ecx, 1 -> ecx에 1을 저장
shl ecx, 4 -> ecx에 저장된 값 1을 왼쪽으로 4칸 시프트 연산을 해서 0001(2) -> 0001 0000(2) = 16(10), ecx = '16'
movsx 스택에서 16번째 인덱스에 있는 값을 가져와 edx에 저장. -> edx = '7'
xor edx, dword ~ edx와 ebp-4에 저장된 값을 xor 연산을 진행을 해서 두 값이 같아야 jump not equal, 즉 점프하지 않으므로
A[16]에 원래 들어있던 값은 0x7D, 즉 '}'

(메모장 켜서 스택의 15번째 인덱스가 'v'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.
이것도 ZF를 1로 바꿔줘서 넘어가줍니다.

### 6번째 인덱스
mov eax, 1 -> eax에 1을 복사해서 저장.
imul ecx, eax, 6 -> eax에 '6'을 곱해서 ecx에 저장 -> ecx = '6'
movsx 스택에서 6번째 인덱스에 저장된 값을 edx에 저장. -> edx = '7'
cmp edx, 33 -> edx를 0x33과 비교, 즉. '3'
(메모장 켜서 스택의 6번째 인덱스가 '3'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 4번째 인덱스(확인용)
mov eax, 1 -> eax에 1을 복사해서 저장.
shl eax, 2 -> eax에 저장된 1을 왼쪽으로 2칸 시프트 연산 0001(2) -> 0100(2) = 4(10), eax = '4'
movsx 스택에서 4번째 인덱스에 저장된 값을 가져와 ecx에 저장
cmp ecx, 7B -> ecx를 0x7B와 비교, 즉. '{'
아까 4번째 인덱스는 확인했기 때문에 ZF만 변경하고 넘어감.

### 8번째 인덱스
mov dword ... ebp-8 위치에 E를 복사해서 저장
점프해서 넘어감
mov edx, 1 -> edx에 1을 복사해서 저장.
shl edx, 3 -> edx에 저장된 값을 왼쪽으로 3칸 시프트 연산 0001(2) -> 1000(2) = 8(10), edx = '8'
movsx 스택에서 8번째 저장된 값을 eax에 저장. -> eax = '9'
mov ecx, 1 -> ecx에 1을 복사해서 저장.
imul edx, ecx, A -> edx에 ecx와 'A'를 곱해서 저장. -> edx = 'A' (A는 10진수로 10)
movsx 스택에서 10번째 인덱스에 있는 값을 가져와 ecx에 저장. -> ecx = '1'
xor eax, ecx -> eax와 ecx를 xor 연산을 해서 eax에 저장
xor eax, dword ptr ss:[ebp-8] -> 3개를 xor 한 값이 0이 되어야 결과가 0, jump하지 않게 됨.

A[8] ^ E(0x0E) ^ m(0x6D) = 0
A[8] ^ 0x63 = 0
A[8] = 0x63 ('c')

(메모장 켜서 스택의 8번째 인덱스가 'c'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 7번째 인덱스
mov edx, 1 -> edx에 1을 복사해서 저장.
imul eax, edx, 7 -> eax에 edx와 '7'을 곱한 값을 저장 -> eax = '7'
movsx 스택에서 7번째 저장된 값을 ecx에 저장. -> ecx = '8'
cmp ecx, 6C -> ecx와 6C를 비교, 즉. 'l'
(메모장 켜서 스택의 7번째 인덱스가 'l'임을 표시.)
jne에서 의도적으로 ZF를 1로 바꿔줌.

### 11번째 인덱스
mov edx, 1 -> edx에 1을 복사해서 저장.
imul eax, edx, B -> edx와 B를 곱한 값을 eax에 저장. -> eax = 'B' (B는 10진수로 11)
movsx 스택에서 11번째 인덱스에 저장된 값을 ecx에 저장. -> ecx = '2'
mov edx, 1 -> edx에 1을 복사해서 저장.
imul eax, edx, 6 -> edx와 6을 곱한 값을 eax에 저장. -> eax = '6'
movsx 스택에서 6번째 인덱스에 저장된 값을 edx에 저장. -> edx = '7'
cmp ecx, edx -> ecx와 edx를 비교해서 jump할지 말지 결정. 즉 6번째 인덱스의 값은 알고 있으므로 A[11] = '3'

### 12번째 인덱스
mov eax, 1 -> eax에 1을 복사해서 저장.
imul ecx, eax, C -> eax와 C를 곱한 값을 ecx에 저장. -> ecx = 'C' (C는 10진수로 12)
movsx 스택에서 12번째 인덱스에 저장된 값을 edx에 저장. -> edx = '3'
cmp edx, 5E -> edx를 0x5E와 비교해서 jump할지 말지 결정.
jle -> jump less equal 앞에 나온 결과와 비교해서 작거나 같으면 점프. 점프가 되면 안되기 때문에 커야함.
0x5E 보다 커야함. ZF = 0, SF = 0 맞춰주고 내려감.

mov eax, 1 -> eax에 1을 복사해서 저장.
imul ecx, eax, C -> eax와 C를 곱한 값을 ecx에 저장. -> ecx = 'C' (C는 10진수로 12)
movsx 스택에서 12번째 인덱스에 저장된 값을 edx에 저장. -> edx = '3'
cmp edx, 60 -> edx를 0x60와 비교해서 jump할지 말지 결정.
jge -> jump greater equal 앞에 나온 결과와 비교해서 크거나 같으면 점프. 점프가 되면 안되기 때문에 작아야함.
0x60보다 작아야함. ZF = 0, SF = 0 맞춰주고 내려감.

0x5E < A[12] < 0x60

A[12] = 0x5F. 즉, '_'

(메모장 켜서 스택의 12번째 인덱스가 '_'임을 표시.)


0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
c a d t  { w 3 l c 0  m  3   _   r  3   v   }

실제 cmd 창에 입력해보고 종료.

우리가 입력해야하는 첫번째 값은 'c'