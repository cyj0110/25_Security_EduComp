# 악성코드

## 바이너리 분석

### 개요

원격훈련체계에서 윈도우 바이너리 분석 ... 내용 읽고 다운로드 유도
1) 가상 자산(윈도우) 오픈
2) 링크 복사 안됨, 직접 보고 입력해서 파일 다운로드 후 저장
3) cmd로 파일 열어보기
4) Hello! Welcome EASY Reversing! -> 무언가 입력했는데 fail 뜨면서 프로그램 종료. 힌트에 리버싱 crackme라고 되어있는 걸 보아, 분석 도구를 이용해 리버싱을 진행

---

### 힌트(풀이시간) - 20분

내용

---

### 문제 풀이

1. 마찬가지로, x32dbg 프로그램을 열면, F9를 눌러 EntryPoint로 진입합니다.
2. 다음을 찾기 -> 현재 모듈 -> 문자열 참조 에서 저번 문제와 비슷하게 %s 서식 지정자와 Good, Fail이 있는 것으로 보아 어떤 특정한 문자열을 입력받아, 성공과 실패로 분기가 될 것이라는 것을 추정할 수 있습니다.
3. 서식 지정자가 있는 주소에 우클릭 -> 중단점(breakpoint) 설정을 누르고 다시 CPU로 돌아옵니다.
4. F9를 눌러 설정한 breakpoint까지 진행을 해보도록 하겠습니다.
5. 다음 명령어로 진행을 하면 더 이상 진행이 되지 않는 것을 알 수가 있는데, 실행 명령어 창에 입력을 해보면 다음 명령어로 넘어가지는 것을 확인할 수 있습니다.
6. 주석을 살펴보면 63: 'c', 61: 'a', 64: 'd' 이렇게 16진수와 그에 해당하는 문자가 뭔지 나타내고 있는 것을 확인할 수 있습니다.
7. 진행을 하다보면 jne 101-03.401249 명령어에서 빨간색 화살표로 점프가 될것이라는 것을 알 수 있는데, jne는 jump if not equal, 즉 같지 않으면 점프라는 뜻이 됩니다.
아까 Zero Flag 값이 0이면 같지 않음, 즉 점프를 하게 되므로, 의도적으로 1로 만들어줘서 프로그램을 의도적으로 조작해볼 수 있습니다.
8. 그러면 점프가 되지 않고, 다음 명령어 줄로 이동하는 것을 알 수가 있습니다.
9. 그런데 여기서 알아야 할 것은 앞으로 나오게 되는 명령어 구조가 이렇게 된다는 것입니다.
```
mov edx, 1
imul eax, edx, 0
movsx ecx, byte ptr ss:[ebp+eax-28]
cmp ecx, 63
jne 101-03.401249
```

이런식의 구조에서 변형되어서 나타내게 됩니다.
우리가 아는 대부분의 CPU의 어셈블리 명령어의 구조는

[Op Code(명령어) opr1 opr2] 의 형태로 이루어져있습니다.
opr1과 opr2를 명령어로 계산해서 opr1에 저장하는 구조입니다.

하나씩 보자면
mov edx, 1은 edx라는 레지스터에 1을 복사해서 저장하라는 뜻입니다.
imul eax, edx, 0은 eax라는 레지스터에 edx와 0을 곱해서 저장하겠다는 뜻입니다.
movsx ecx, byte ptr ss:[ebp+eax-28] 은 ss라는 스택에서 ebp+eax-28의 값을 가져와 ecx에 저장한다는 뜻입니다.
EBP, ESP는 스택에서 쓰이는 레지스터인데, ebp 에서 28을 뺀 값이 esp 라는 것을 확인할 수 있다. (덤프에서 따라가기 해서 cmd 창에 내가 입력한 내용 보여주기) 그래서 레지스터 값을 더하면 이 스택 배열에서 인덱스 값으로 쓰인다는 것을 확인할 수 있음.
cmp ecx, 63 ecx와 0x63을 비교해서 그 다음 ZF를 설정하는데, 같으면 1, 같지 않으면 0으로 설정됩니다. 그래서 보통 다음에 jump 문이 나옵니다.
jne 101-03.401249 즉 아까 설명했듯이 같지 않으면 점프이므로, ZF가 0이면 점프, 1이면 점프하지 않게 됩니다.

### 0번째 인덱스
이런식의 명령어 구조를 기억한 채로, 실행시키면서 보도록 하겠습니다.
(첫번째 'c' 보여주면서 ZF 통과)
(메모장 켜서 스택의 0번째 인덱스가 'c' 임을 표시.)

### 1번째 인덱스
다음 구조는 mov edx, 1 -> edx 레지스터에 1을 저장하고
shl edx, 0 비트연산을 진행하는 명령어 인데, shift left 즉 왼쪽으로 비트를 이동시키는 연산입니다. 그런데 지금은 0으로 되어있으니 움직이지 않습니다. edx는 여전히 1입니다.
movsx 스택은 1번째 인덱스라는 것을 표시 eax에는 '(사용자가 입력한 1번째 내용)'이 저장
cmp eax, 61 -> '2'와 'a'는 다르므로 점프가 됨.
jne 에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 1번째 인덱스가 'a' 임을 표시.)

### 2번째 인덱스
그 다음은 mov ecx, 1 -> ecx 레지스터에 1을 저장하고
shl ecx, 1 -> ecx 레지스터에 저장된 값인 1을 왼쪽으로 1칸 옮기는 연산입니다.
0001(2) -> 0010(2) = 2(10) ecx에는 '(사용자가 입력한 2번째 내용)'이 저장됩니다.
movsx 스택에서 2번째 인덱스에는 '3'이 저장되어 있고, edx에 '3'이 저장됨.
cmp edx, 64 -> '3'과 'd'는 다르므로 점프가 됨.
jne 에서 의도적으로 ZF를 1로 바꿔줌.
(메모장 켜서 스택의 2번째 인덱스가 'd'임을 표시.)

### 3번째 인덱스
